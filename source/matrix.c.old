
   /**------ ( ----------------------------------------------------------**
    **       )\                      CAnDL                               **
    **----- /  ) --------------------------------------------------------**
    **     ( * (                    matrix.c                             **
    **----  \#/  --------------------------------------------------------**
    **    .-"#'-.        First version: december 9th 2005                **
    **--- |"-.-"| -------------------------------------------------------**
    |     |
    |     |
 ******** |     | *************************************************************
 * CAnDL  '-._,-' the Chunky Analyzer for Dependences in Loops (experimental) *
 ******************************************************************************
 *                                                                            *
 * Copyright (C) 2005 Cedric Bastoul                                          *
 *                                                                            *
 * This is free software; you can redistribute it and/or modify it under the  *
 * terms of the GNU General Public License as published by the Free Software  *
 * Foundation; either version 2 of the License, or (at your option) any later *
 * version.                                                                   *
 *                                                                            *
 * This software is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY *
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   *
 * for more details.                                                          *
 *                                                                            *
 * You should have received a copy of the GNU General Public License along    *
 * with software; if not, write to the Free Software Foundation, Inc.,        *
 * 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA                     *
 *                                                                            *
 * CAnDL, the Chunky Dependence Analyzer                                      *
 * Written by Cedric Bastoul, Cedric.Bastoul@inria.fr                         *
 *                                                                            *
 ******************************************************************************/
/* CAUTION: the english used for comments is probably the worst you ever read,
 *          please feel free to correct and improve it !
 */

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <candl/candl.h>
#include <candl/matrix.h>
#include <candl/piplib-wrapper.h>
#include <piplib/piplib.h>
#include <osl/macros.h>
#include <clay/beta.h>



/**
 * candl_matrix_violation function :
 * this function builds the constraint system corresponding to a violation of a
 * dependence, for a given transformation couple at a given depth.
 * - dependence is the constraint system of a dependence between two
 statements,
 * - t_source is the transformation function for the source statement,
 * - t_target is the transformation function for the target statement,
 * - dimension is the transformation dimension checked for legality,
 * - nb_par is the number of parameters.
 ***
 * - 13/12/2005: first version (extracted from candl_violation).
 */
osl_relation_p candl_matrix_violation(osl_relation_p dependence,
                                      osl_relation_p t_source,
                                      osl_relation_p t_target,
                                      int dimension, int nb_par) {
  osl_relation_p system;
  int i, j;
  int nb_rows, nb_columns;
  int constraint;
  int s_dims, t_dims;
  int row_src, row_targ;
  int precision = dependence->precision;
  osl_int_p temp = osl_int_malloc(precision);
  
  /* The number of dimensions of the source and target domains. */
  /* target and source are scattering matrix */
  s_dims = t_source->nb_input_dims;
  t_dims = t_target->nb_input_dims;

  /* Size of the constraint system. */
  nb_rows    = dependence->nb_rows + dimension + 1;
  nb_columns = dependence->nb_columns;

  /* We allocate memory space for the constraint system. */
  system = osl_relation_pmalloc(precision, nb_rows, nb_columns);
  
  /* We fill the constraint system (there is no need to put zeros in the
   * empty zones since candl_matrix_alloc initialized all to 0)
   */
  
  /* 1. We copy the constraints of the dependence polyhedron. */
  for (i = 0; i < dependence->nb_rows; i++)
    for (j = 0; j < dependence->nb_columns; j++)
      osl_int_assign(precision,
                     system->m[i], j,
                     dependence->m[i], j);

  constraint = dependence->nb_rows;

  /* 2. We set the equality constraints (equality tag is already 0). */
  for (i = 0; i < dimension; i++) {
    row_src = clay_relation_get_line(t_source, i);
    row_targ = clay_relation_get_line(t_target, i);
    
    /* The source dimension part. */
    for (j = 1; j <= s_dims; j++)
      osl_int_assign(precision,
                     system->m[constraint], j,
                     t_source->m[row_src], j + t_source->nb_output_dims);

    /* The -target dimension part. */
    for (; j <= s_dims + t_dims; j++) {
      osl_int_oppose(precision,
                     temp, 0,
                     t_target->m[row_targ], j - s_dims + t_target->nb_output_dims);
      osl_int_assign(precision,
                     system->m[constraint], j,
                     temp, 0);
    }

    /* The source-target parameter/scalar part. */
    for (; j < nb_columns; j++)
      osl_int_sub(precision,
                  system->m[constraint], j,
                  t_source->m[row_src], j - t_dims + t_source->nb_output_dims,
                  t_target->m[row_targ], j - s_dims + t_target->nb_output_dims);

    constraint++;
  }
  
  /* 3. We set the target < source constraint. */
  /* This is an inequality. */
  osl_int_set_si(precision, system->m[constraint], 0, 1);

  row_src = clay_relation_get_line(t_source, dimension);
  row_targ = clay_relation_get_line(t_target, dimension);

  /* The source dimension part. */
  for (j = 1; j <= s_dims; j++)
    osl_int_assign(precision,
                   system->m[constraint], j,
                   t_source->m[row_src], j + t_source->nb_output_dims);

  /* The -target dimension part. */
  for (; j <= s_dims + t_dims; j++) {
    osl_int_oppose(precision,
                   temp, 0,
                   t_target->m[row_targ], j - s_dims + t_target->nb_output_dims);
    osl_int_assign(precision,
                   system->m[constraint], j,
                   temp, 0);
  }

  /* The source-target parameter/scalar part. */
  for (; j < nb_columns; j++)
    osl_int_sub(precision,
                system->m[constraint], j,
                t_source->m[row_src], j - t_dims + t_source->nb_output_dims,
                t_target->m[row_targ], j - s_dims + t_target->nb_output_dims);

  /* We subtract 1 to the scalar to achieve >0 constraint. */
  osl_int_decrement(precision,
                    system->m[constraint], nb_columns - 1,
                    system->m[constraint], nb_columns - 1);

  osl_int_free(precision, temp, 0);
  
  osl_relation_dump(stdout, system);
  
  system->nb_output_dims = 0;
  system->nb_input_dims = 0;
  system->nb_parameters = nb_par;
  system->nb_local_dims = 0;
  system->type = OSL_TYPE_DOMAIN;
  
  return system;
}


/**
 * candl_matrix_check_point function:
 * This function checks if there is an integral point in the set of
 * constraints, provided a given domain (possibly NULL).
 *
 * FIXME : is it the same as pip_has_rational_point ?
 * here options->Nq = 1 (default)
 */
int
candl_matrix_check_point(osl_relation_p domain,
                         osl_relation_p context) {
// FIXME : compatibility with osl
//#ifdef CANDL_HAS_PIPLIB_HYBRID
//  return piplib_hybrid_has_integer_point (domain, context, 0);
//#else  
  PipOptions* options;
  PipQuast* solution;
  int ret = 0;
  options = pip_options_init();
  options->Simplify = 1;
  options->Urs_parms = -1;
  options->Urs_unknowns = -1;
  
  solution = pip_solve_osl(domain, context, -1, options);

  if ((solution != NULL) &&
      ((solution->list != NULL) || (solution->condition != NULL)))
    ret = 1;
  pip_options_free(options);
  pip_quast_free(solution);

  return ret;
//#endif  
}

